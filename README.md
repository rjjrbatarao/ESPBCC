# Esp chained IV block udp encryption
Udp broadcast encryption using block chain inspired algorithm

## Why
I stumbled accross a problem in simple AES encrypted command messages, i was sending simple command on and off and with fixed iv and key the cipher text were always identical, so if an attacker captures this command and send it to the udp network then the devices will parse and decode this to be authentic and valid. One solution is to encrypt a new IV along with the command message and use this to decode the succeeding ciphertext the problem is the receiver will always rely on the past sent IV to decode its message. That might be the answer but i thought of a way to get a synchronized IV without sending this along with the message. By hashing the same IV block again you could create identical IV block just by knowing the starting IV block value and how many times it was hashed.IV Synchronization is determined by how many times it was hashed so does it mean i need to store how many times it was hashed to get the current iv? no you dont, you will store the last hased IV block not the counter, then if i store the IV block instead of the counter how can I synchronize this on the other end? Solution is simple you just need to create a ciphertext out of a synchronization code send this from a requesting receiver, the receiver must parse then in a aes decoding loop starting with the stored hashed iv block, and when the syncronization code matched then the current iv is sychronized, the current iv block then will be used in every messages encryption since it is already syncronized with the other devices, every node that wants to join the secured decentrallized network by working on decoding a syncronization code and its more like mining, the syncronization code is kept secret along with the iv the key. The algorithm works in udp by ulitizing it capability of broadcasting messages to all connected device. Why broadcast ? this is to ensure that every device in the network must update its IV by hashing it again whenever one device has sent a message, how do you say the message is valid? message is said to be valid if the aes decoded data prefix matched a data code, every data code must have a prefix of this data code prefix and kept secret along with the other codes and keys mentioned above. The sender then updates its iv into a new hashed iv if one of the receivers acknowleges its message. note that an acknowledgement code prefix is also encrypted. All of the stated method and encryption pattern creates a very diversified stream of encrypted data on the newtwork and replay attacks is impossible, even if you deliberately request a encrypted sync code, you cannot decode this as it will be updated again into a new one whenever one device sents a new data.
